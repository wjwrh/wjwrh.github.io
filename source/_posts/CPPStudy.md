---
title: CPPStudy
date: 2018-10-04 12:50:14
tags:
  - C++
categories: 计科相关
comments: false
---

# CPP学习记录

写在前面:

这可能是我写过的最早的一篇博客了，同期的还有许多，但是因为内容过于空洞，在我大更新博客之后没有打算保留，保留这一篇的原因仅仅是因为只有这一篇稍微够看...这篇博客记录了我学习`《C++ Primer Plus 6th Edition》`的过程，也算是我走进计科领域迈出的第一步，因此我觉得保留下这一篇还是比较有意义的。

<!-- more -->

## 第八章.函数探幽

---
### 1.内联函数
在编译时每一个调用函数的地方插入整个函数代码

优点：调用函数时不需要保存原有代码地址、跳转、执行再跳转回原有代码，能够加快程序运行速度

缺点：占用内存的量增大，在每一个调用函数的地方都要插入整个函数代码

语法：在函数声明与函数定义前加上关键字 inline，内联函数一般都省略掉函数声明，而是在函数声明的地方便输入整个函数代码


### 2.引用变量
使用另外一个名称来表示已经存在的一个变量

用途：在传递函数参数时，如果函数想要修改原有变量的值，则需要使用引用（使用指针也可）举一个例子：
```
using namespace std;
void swap1(int,int);
void swap2(int &,int &);

int main()
{
  int a = 1;
  int b = 2;
  swap1(a,b);
  cout << "Used swap1 : a= "<< a << "  b= "<< b << endl;
  swap2(a,b);
  cout << "Used swap2 : a= "<< a << "  b= "<< b << endl;
  return 0;
}

void swap1(int x,int y)
{
  int temp = y;
  y = x;
  x = temp;
}

void swap2(int &x,int &y)
{
  int temp = y;
  y = x;
  x = temp;
}
```

执行结果:
![执行结果](\院科协二试\图片1.png)

不使用引用在传递参数时，会生成不同于原参数的两个形参，并且随着函数的结束，形参的占用的内存也会被释放，而使用引用，相当于为参数的内存地址取了另外一个名字，示例中x与a代表的是同一个内存地址，改变x也就等于改变a。

一般情况下，能够被引用的只有左值，如果在本该提供左值作为参数的地方提供了右值或参数数据类型不匹配的左值但能够进行数据转换，且在声明函数时声明为const引用，那么程序就会创造一个类型匹配的临时变量，并将其引用进行函数执行。

---
### 3.默认参数
在函数原型处可以声明默认参数（记住函数定义处不必也不能写出）
当提供给函数的参数数量不足时可以进行自动补全
Tips：默认参数只能从右至左声明，提供函数参数只能从左至右不能留空

---
### 4.函数重载
同名函数参数列表不同即可进行重载，提供参数时根据参数列表进行匹配
Tips：引用（int &x）与直接使用（int x）参数列表相同
const变量能够赋值给const变量，不能复制给非const变量
编写两个函数或多个函数时，每一个函数都会占用内存空间

---
### 5.函数模板
用途：可以利用泛型来定义函数，并根据实际情况用符合的具体类型替换泛型

语法：
```
template <class Type>
void Swap(Type &,Type &);

int main()
{
  double x = 1 , y = 2;
  char a = 'q', b = 'z';
  cout << "Now x,y= "<< x << " " << y << "\na,b= "<< a << " " << b;
  Swap (x,y);
  Swap (a,b);
  cout << "\nSwap!!\n";
  cout << "Now x,y= "<< x << " " << y << "\na,b= "<< a << " " << b;
  return 0;
}

template <class Type>
void Swap(Type &m,Type &n)
{
  Type temp;
  temp = n;
  n = m
  m = temp;
}
```
其中Type是一种自定标识符，可以修改成更易理解的字符  

显式具体化：
当想要对传递给函数的参数为特殊的类型时，想执行特定的操作（例如当传递给Swap函数的参数为两个结构的引用，但是不想交换个整结构，而是交换特定的成员时），可以使用显式具体化  

语法：  
`template <> void Swap(int &, int &);`  
类似于函数重载，需要另外定义该函数

实例化：
当想要传递给函数两个不同类型的数据时，默认情况下是不被允许的，但是如果使用实例化，编译器便会进行强制类型转换

语法：
```
using namespace std;
template <class Type>
Type ADD(const Type&,const Type&);

int main()
{
	double x = 1;
	int y = 2;
	cout << ADD<double>(x, y);
}

template <class Type>
Type ADD(const Type& m,const Type& n)
{
	return m + n;
}
```
在函数名后面添加<>并填入转换类型。

对于使用有多种模板的函数，在不确定的情况下想要声明一个不确定类型的变量，可以使用关键字decltype

后置返回类型：
如果预先不知道函数的返回值类型，可以使用后置返回类型
格式：  
auto 函数名(参数列表) -> 返回类型(可以使用decltype)

---
---

## 第九章.内存模型和名称空间
---
### 1.单独编译
当想要在多个源文件中使用同一结构时，可以在一个头文件中包含结构的声明，并在源文件中包含该头文件

使用预编译器让头文件仅编译一遍：

原理
```
#ifndef abc
#define abc
  头文件内容
#endif
```

仅当ifndef后面的名字没有被定义时，才会执行ifndef与endif语句之间的内容

---
### 2.存储持续性、作用域和链接性
在代码块的外部声明的变量为具有外部链接性的静态持续变量，在代码块外部用static声明的变量为具有内部链接性的静态持续变量，而在代码块内部用static声明的变量为无链接性的静态持续变量，第一种可在外部文件中调用，而第二种只能在本文件中调用，第三种只能在对应代码块中调用，但是他们在程序的生命周期中会一直存在。

在另一个文件中使用具有外部链接性的变量时，需要先进行引用声明，即使用关键字extern

利用static定义的无链接性的静态持续变量，只在程序运行时进行一次初始化

例如：
```
void strcount (const char * str)
{
  using namespace std;
  static int total = 0;
  int count = 0;
  .....
}
```

其中count变量在每次调用该函数时都将被重置为0，而total变量仅在程序运行时被重置为0，之后都不会再被重置

在函数外声明的const变量链接性是内部的，即仅在文件内可被调用，这也是可以在头文件中声明const变量而不会发生重复声明变量错误的原因。如果想让const变量具有外部链接性，则需要在声明前加入extern。

函数也是具有链接性的，一般情况下函数的链接性为外部的，可以使用static关键字来使其仅有内部链接性，这样在别的文件中就无法调用该函数。（需要在原型与定义时同时加入关键字static）

---
### 3.名称空间
为了避免变量名称之间的冲突，可以使用名称空间，不同名称空间之间的同名关键字永远不会发生冲突

语法：
```
namespace (name) {
  ...
}
```
除非名称空间中引用了常量，否则其中的变量都具有外部链接性。可以使用using指令使用名称空间中的一个变量或使用整个名称空间，例如：
```
namespace Ruby{
  double age = 18;
  char name[20] = "KurosawaRuby";
}
using Ruby::age;    //这样在接下来的编译中age将使用Ruby名称空间中的值
using namespace Ruby;   //在接下来的编译中每一个age和name都将使用Ruby中的值
```
---
---
## 第十章.对象和类
---

最重要的面对对象编程特性:
* 抽象
* 封装和数据隐藏
* 多态
* 继承
* 代码的可重用性

---
### 1.抽象和类
类声明:
```
class 类名
{
  private:
    私有成员
  public:
    公有成员
}
```
类声明通常放在头文件中，以便提供维护和管理，私有成员只能由类成员来访问，外部函数（除友元函数外）访问类成员是非法的，为类设计成员函数时，如果不想使用内联函数，只用在类定义中提供函数原型，在另外的文件中提供函数定义，而在类定义中就提供函数定义的，将默认识别为内联函数。

注意几点：
* 为成员函数提供定义时，要在函数名前面加上作用域限定符(类名::函数名)
* 一般情况下将数据成员放在私有部分，将成员函数放在共有部分
* 不同的类对象使用各自的数据成员，而共用一组成员函数
* 在类函数定义内，可以自由调用作用域为该类的变量

例子:

#### Ruby.h
---
```
#ifndef _RUBY_
#define _RUBY_
class Ruby
{
  private:
    int x;
    int y;
    int z;
  public:
    void acquire(int,int,int);
    int sum();
};
#endif
```
#### Ruby.cpp
---
```
#include "Ruby.h"
void Ruby::acquire(int a,int b,int c)
{
  x=a;
  y=b;
  z=c;
}

int Ruby::sum()
{
  return x+y+z;
}
```
---
### 2.类的构造函数和析构函数
构造函数：可以为类的对象进行初始化，构造函数应与类具有相同的名称，举一个例子
```
class Ruby
{
  private:
    int x;
    int y;
    string name;
  public:
    Ruby(int = 0,int = 0,const string & = "none");
};
// 暂时省略类定义
```
上面的声明中使用了默认参数，在没提供初始变量或者提供部分初始变量时也能成功完成初始化工作，注意，如果想全部使用初始值，不要用下面第一种声明方式！！
```
Ruby test();  //这是一个返回Ruby对象的函数的原型
Ruby test;    //这才是正确姿势
```
如果没有为类设计构造函数，C++会隐式提供默认的构造函数，即全部使用空值构造

析构函数：在类对象过期（声明其所在的代码块结束、被delete指令删除等等）的时候，会调用析构函数（如果没有定义编译器会隐式提供一个不进行任何行为的析构函数），通常在构造函数中用new声明的成员变量，在析构函数中利用delete进行删除

如果使用const来声明类对象，则一般情况下的成员函数都将无法使用！！因为编译器无从得知成员函数是否会修改类对象的数据成员，这种情况下，在声明成员函数时应该也添加上const关键字，具体格式如下：
```
//成员函数声明
...
int sum() const;
...

//成员函数定义
int Ruby::sum() const
{
  return x+y+z;
}
```
所以
**在确认成员函数不会修改数据成员时，都应加上const变量**

